---
type Version = "jp" | "us" | "pal" | "ique";

interface Props {
  version: Version
}

const structure = {
  timestamp: parseInt,
  commit: (s: string) => s,
  totalFuncs: parseInt,
  nonMatchingFuncs: parseInt,
  matchingFuncs: parseInt,
  totalBytes: (b: string) => parseInt(b),
  nonMatchingBytes: (b: string) => parseInt(b),
  matchingBytes: (b: string) => parseInt(b),
};

type ParsedRow = {
  [Key in keyof typeof structure]: ReturnType<typeof structure[Key]>
};

type RowWithPercent = ParsedRow & { percentBytes: number };

const colors = {
  green: { stroke: "#40e334", fill: "#91eb7f" },
  yellow: { stroke: "#e3ac34", fill: "#edc97e" },
  blue: { stroke: "#3d76da", fill: "#1e3b6d" },
  orange: { stroke: "#cc8400", fill: "#ffa500" },
};

async function fetchData(version: Version): Promise<RowWithPercent[]> {
  const csv = await fetch(
    `https://papermar.io/reports/progress_${version}.csv`
  ).then((response) => response.text());

  const rows = csv
    .split("\n")
    .filter((row) => row.length)
    .map((row) => {
      const [version, ...data] = row.split(",");
		if (version !== "1") {
			throw new Error(`invalid CSV row: ${row}`);
		}
      return Object.entries(structure).reduce(
        (acc, [key, transform]) => ({
          ...acc,
          [key]: transform(data.shift()!),
        }),
        {} as ParsedRow
      );
    });

  const latest = rows[rows.length - 1];

  const totalBytes = latest.totalBytes;

  return rows.map((row) => ({
    ...row,
    percentBytes: (row.matchingBytes / totalBytes) * 100,
  }));
}

console.log(await fetchData(Astro.props.version));
---
